\subsection{Depth-wise Separable Convolution 2D Using TI LEA}
Depth-wise separable convolution is an efficient form of convolution that reduces the computational cost compared to standard convolution. Here we describe the implementation of depth-wise separable convolution 2D using the Low Energy Accelerator (LEA) in Texas Instruments' MSP430 microcontrollers.

\subsubsection{depth-wise Separable Convolution 2D Using Conv1D}
\label{appendix:pDWSC}
%%%%%
The pseudo code described in Algorithm~\ref{algo:conv1D2conv2D-here} implements a depth-wise separable convolution 2D (DWSConv2D) using a 1D convolution primitive function (conv1D). The DWSConv2D function takes four inputs: an input matrix, depth-wise kernels (DWsKernels), point-wise kernels (PtWsKernel), and an output matrix. The depth-wise separable convolution is performed in two main steps: depth-wise convolution and point-wise convolution.
%\input{Algos/conv1DtoDWSconv2D}
\begin{algorithm}[H]
\caption{Implementing Depth-wise Separable Convolution - DWSConv2D() using CONV1D ()}
\begin{algorithmic}[1]
\State \textbf{Function} DWSepConv2D($inputMatrix$, $DWsKernels$, $PtWsKernel$, $outputMatrix$):
\State \quad Initialize $DWsOutput$ with zero values, same shape as $inputMatrix$
\State \quad \# Depth-wise Separable (DWs) convolution
\State \quad \textbf{for} $c \leftarrow 0$ \textbf{to} $channels(inputMatrix) - 1$:
\State \quad \quad \# Apply 1D convolution along rows
\State \quad \quad \textbf{for} $i \leftarrow 0$ \textbf{to} $rows(inputMatrix[c]) - 1$:
\State \quad \quad \quad conv1D($inputMatrix[c][i, :]$, $DWsKernels[c][0, :]$, $DWsOutput[c][i, :]$)
\State \quad \quad \# Apply 1D convolution along columns
\State \quad \quad \textbf{for} $j \leftarrow 0$ \textbf{to} $cols(DWsOutput[c]) - 1$:
\State \quad \quad \quad conv1D($DWsOutput[c][:, j]$, $DWsKernels[c][:, 0]$, $DWsOutput[c][:, j]$)
\State \quad \# Point-wise (PtWs) convolution
\State \quad Initialize $finalOutput$ with zero values, with shape [rows($DWsOutput$), cols($DWsOutput$), channels($PtWsKernel$)]
\State \quad \textbf{for} $i \leftarrow 0$ \textbf{to} $rows(DWsOutput) - 1$:
\State \quad \quad \textbf{for} $j \leftarrow 0$ \textbf{to} $cols(DWsOutput) - 1$:
\State \quad \quad \quad \textbf{for} $k \leftarrow 0$ \textbf{to} $channels(PtWsKernel) - 1$:
\State \quad \quad \quad \quad Initialize $PtWsSum \leftarrow 0$
\State \quad \quad \quad \quad \textbf{for} $c \leftarrow 0$ \textbf{to} $channels(DWsOutput) - 1$:
\State \quad \quad \quad \quad \quad $PtWsSum \leftarrow PtWsSum + DWsOutput[c][i][j] \times PtWsKernel[c][k]$
\State \quad \quad \quad \quad $finalOutput[i][j][k] \leftarrow PtWsSum$
\State \quad \textbf{return} $finalOutput$
\end{algorithmic}
\label{algo:conv1D2conv2D-here}
\end{algorithm}


% {\textbf{Explanation}}

% {Step 1: Depth-wise Separable (DWs) Convolution}

% The first step in the DWSConv2D function is to perform depth-wise separable convolution. This process involves applying 1D convolution along both the rows and columns of each channel in the input matrix. The depth-wise convolution is done separately for each channel using its corresponding filter in the DWsKernels.

% \begin{itemize}
%     \item \textbf{Initialize DWsOutput}: A matrix of zeros with the same shape as the input matrix.
%     \item \textbf{Loop over channels}: For each channel in the input matrix:
%     \begin{itemize}
%         \item \textbf{1D Convolution along Rows}: For each row in the channel, apply the 1D convolution using the conv1D function with the corresponding row filter from DWsKernels.
%         \item \textbf{1D Convolution along Columns}: For each column in the DWsOutput channel, apply the 1D convolution using the conv1D function with the corresponding column filter from DWsKernels.
%     \end{itemize}
% \end{itemize}

% {Step 2: Point-wise (PtWs) Convolution}

% The second step is to perform point-wise convolution on the depth-wise convolved output (DWsOutput). This involves applying the PtWsKernel to each spatial position in the DWsOutput across all channels.

% \begin{itemize}
%     \item \textbf{Initialize finalOutput}: A matrix of zeros with the shape [rows(DWsOutput), cols(DWsOutput), channels(PtWsKernel)].
%     \item \textbf{Loop over spatial positions} ($i$, $j$): For each spatial position in DWsOutput:
%     \begin{itemize}
%         \item \textbf{Loop over point-wise filters} ($k$): For each filter in PtWsKernel:
%         \begin{itemize}
%             \item Initialize $PtWsSum$ to zero.
%             \item \textbf{Accumulate the point-wise sum}: For each channel in DWsOutput, multiply the value at the spatial position by the corresponding value in PtWsKernel and add to $PtWsSum$.
%             \item Assign $PtWsSum$ to the corresponding position in finalOutput.
%         \end{itemize}
%     \end{itemize}
% \end{itemize}

% The function finally returns the result stored in $finalOutput$.


%%%%%%


\subsubsection{Pseudocode with micro-controller primitives}
\label{appendix:leaDWSC}
The following pseudocode describes the steps to implement depth-wise separable convolution using LEA primitives from TI's DSP Library.

\begin{algorithm}[H]
\caption{depth-wise Separable Convolution 2D Using TI LEA}
\begin{algorithmic}[1]
\Function{DWSepConv2D}{$inputMatrix$, $DWsKernels$, $PtWsKernel$, $outputMatrix$}
    \State Initialize $tempMatrix1$ and $tempMatrix2$ with zero values, same shape as $inputMatrix$
    \State // Depth-wise convolution
    \For{$c \gets 0$ \textbf{to} $channels(inputMatrix) - 1$}
        \State // Apply 1D convolution along rows
        \For{$i \gets 0$ \textbf{to} $rows(inputMatrix[c]) - 1$}
            \State \Call{msp\_conv\_iq31}{$inputMatrix[c][i, :]$, $DWsKernels[c][0, :]$, $tempMatrix1[c][i, :]$, $cols(inputMatrix)$, $FILTER\_SIZE$}
        \EndFor
        \State // Apply 1D convolution along columns
        \For{$j \gets 0$ \textbf{to} $cols(tempMatrix1[c]) - 1$}
            \State \Call{msp\_conv\_iq31}{$tempMatrix1[c][:, j]$, $DWsKernels[c][:, 0]$, $tempMatrix2[c][:, j]$, $rows(tempMatrix1)$, $FILTER\_SIZE$}
        \EndFor
    \EndFor
    \State // Point-wise convolution
    \State Initialize $finalOutput$ with zero values, shape [rows($tempMatrix2$), cols($tempMatrix2$), channels($PtWsKernel$)]
    \For{$i \gets 0$ \textbf{to} $rows(tempMatrix2) - 1$}
        \For{$j \gets 0$ \textbf{to} $cols(tempMatrix2) - 1$}
            \For{$k \gets 0$ \textbf{to} $channels(PtWsKernel) - 1$}
                \State Initialize $PtWsSum \gets 0$
                \For{$c \gets 0$ \textbf{to} $channels(tempMatrix2) - 1$}
                    \State $PtWsSum \gets PtWsSum + tempMatrix2[c][i][j] \times PtWsKernel[c][k]$
                \EndFor
                \State $finalOutput[i][j][k] \gets PtWsSum$
            \EndFor
        \EndFor
    \EndFor
    \State \Return $finalOutput$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Implementation Code}
C code that implements the pseudo-code using TI's LEA~\cite{ti_msp_lea} functions.

\begin{verbatim}
#include <msp430.h>
#include "DSPLib.h"

#define ROWS 64
#define COLS 64
#define CHANNELS 3
#define FILTER_SIZE 3

// Initialize your input, depth-wise kernels, point-wise kernels, 
// and output matrices appropriately
_q31 inputMatrix[CHANNELS][ROWS][COLS];
_q31 DWsKernels[CHANNELS][FILTER_SIZE][FILTER_SIZE];
_q31 PtWsKernel[CHANNELS][CHANNELS];
_q31 tempMatrix1[CHANNELS][ROWS][COLS];
_q31 tempMatrix2[CHANNELS][ROWS][COLS];
_q31 finalOutput[ROWS][COLS][CHANNELS];

void DWSepConv2D() {
    // Depth-wise convolution
    for (int c = 0; c < CHANNELS; c++) {
        // Apply 1D convolution along rows
        for (int i = 0; i < ROWS; i++) {
            msp_conv_iq31(&inputMatrix[c][i][0], DWsKernels[c][0], 
            &tempMatrix1[c][i][0], COLS, FILTER_SIZE);
        }
        // Apply 1D convolution along columns
        for (int j = 0; j < COLS; j++) {
            msp_conv_iq31(&tempMatrix1[c][0][j], DWsKernels[c][0], 
            &tempMatrix2[c][0][j], ROWS, FILTER_SIZE);
        }
    }
    
    // Point-wise convolution
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            for (int k = 0; k < CHANNELS; k++) {
                _q31 PtWsSum = 0;
                for (int c = 0; c < CHANNELS; c++) {
                    PtWsSum += tempMatrix2[c][i][j] * PtWsKernel[c][k];
                }
                finalOutput[i][j][k] = PtWsSum;
            }
        }
    }
}
\end{verbatim}

%\newpage
\subsection{Task-Based Conv2D}
\label{appendix:AQuantaTask}
Here we describe the implementation of a task-based `CONV2D` function using the Low Energy Accelerator (LEA) in Texas Instruments' MSP430 microcontrollers. The function is designed to handle energy constraints by decomposing the convolution loops into smaller quanta tasks. Foloowing are the outline of the requirements:
\begin{enumerate}
    \item Define `QuantaTask` as the minimum iterations that can run.
    \item Decomposable loops: Each `QuantaTask` runs a certain part of the loop.
    \item Check for sufficient energy before launching a `QuantaTask`.
    \item Fuse multiple `QuantaTask`s to minimize load/store operations.
    \item Check for power loss after each `QuantaTask` or fused `QuantaTask` and checkpoint if necessary.
\end{enumerate}
\newpage

\begin{algorithm}[H]\small
\caption{Task-Based CONV2D Using TI LEA}
\label{algo:QuantaConv}
\begin{algorithmic}[1]
\State \textbf{Define} $QuantaTask$ as the minimum iterations we can run
\Function{TaskBasedCONV2D}{$inputMatrix$, $kernel$, $outputMatrix$}
    \State Initialize $tempMatrix$ with zero values, same shape as $inputMatrix$
    \State $rows \gets \text{rows of } inputMatrix$
    \State $cols \gets \text{cols of } inputMatrix$
    \State $kernelSize \gets \text{size of } kernel$
    
    \State $i \gets 0$
    \While{$i < rows$}
        \State $j \gets 0$
        \While{$j < cols$}
            \State $remainingEnergy \gets \Call{CheckEnergy}{QuantaTask}$
            \If{$remainingEnergy$ is sufficient}
                \State \Call{ExecuteQuantaTask}{$i, j, inputMatrix, kernel, tempMatrix$}
                \State \Call{UpdateProgress}{$i, j, QuantaTask$}
                \If{\Call{PowerLossDetected}{}}
                    \State \Call{Checkpoint}{$i, j, tempMatrix$}
                    \State \textbf{break}
                \EndIf
            \Else
                \State \textbf{wait for energy to replenish}
            \EndIf
        \EndWhile
    \EndWhile
    
    \State \Call{FuseTasks}{}
    \State \Return $outputMatrix$
\EndFunction

\Function{ExecuteQuantaTask}{$i, j, inputMatrix, kernel, tempMatrix$}
    \For{$ki \gets 0$ \textbf{to} $kernelSize - 1$}
        \For{$kj \gets 0$ \textbf{to} $kernelSize - 1$}
            \State \Call{msp\_conv\_iq31}{$inputMatrix[i + ki][j + kj]$, $kernel[ki][kj]$, $tempMatrix[i][j]$, $cols$, $kernelSize$}
        \EndFor
    \EndFor
\EndFunction

\algnewcommand\algorithmicbreak{\textbf{break}}
\algnewcommand\Break{\algorithmicbreak}

\Function{FuseTasks}{}
    \State $remainingEnergy \gets \Call{CheckEnergy}{multiple\_QuantaTask}$
    \While{$remainingEnergy$ is sufficient}
        \State \Call{ExecuteQuantaTask}{$i, j, inputMatrix, kernel, tempMatrix$}
        \State \Call{UpdateProgress}{$i, j, multiple\_QuantaTask$}
        \State $remainingEnergy \gets \Call{CheckEnergy}{multiple\_QuantaTask}$
        \If{\Call{PowerLossDetected}{}}
            \State \Call{Checkpoint}{$i, j, tempMatrix$}
            \Break
        \EndIf
    \EndWhile
\EndFunction

\Function{CheckEnergy}{$QuantaTask$}
    \State \# Check if there is enough energy to run the quanta task
    \State \Return $remainingEnergy$
\EndFunction

\Function{PowerLossDetected}{}
    \State \# Check if power loss is detected
    \State \Return $powerLoss$
\EndFunction

\Function{Checkpoint}{$i, j, tempMatrix$}
    \State \# Save the current state to non-volatile memory
\EndFunction

\Function{UpdateProgress}{$i, j, QuantaTask$}
    \State \# Update loop indices based on the quanta task executed
    \State $j \gets j + QuantaTask$
    \If{$j \geq cols$}
        \State $j \gets 0$
        \State $i \gets i + QuantaTask$
    \EndIf
\EndFunction

\end{algorithmic}
\end{algorithm}

\subsubsection{Implementation Code}
\begin{verbatim}
#include <msp430.h>
#include "DSPLib.h"

#define ROWS 64
#define COLS 64
#define KERNEL_SIZE 3
#define QuantaTask 8

// Define the FeRAM addresses for storing the checkpoint data
#define FERAM_ADDR_I 0xF000
#define FERAM_ADDR_J 0xF002
#define FERAM_ADDR_TEMPMATRIX 0xF004

_q31 inputMatrix[ROWS][COLS];
_q31 kernel[KERNEL_SIZE][KERNEL_SIZE];
_q31 tempMatrix[ROWS][COLS];
_q31 outputMatrix[ROWS][COLS];

void TaskBasedCONV2D() {
    int rows = ROWS;
    int cols = COLS;
    int kernelSize = KERNEL_SIZE;
    int i = 0;
    
    while (i < rows) {
        int j = 0;
        while (j < cols) {
            int remainingEnergy = CheckEnergy(QuantaTask);
            if (remainingEnergy > 0) {
                ExecuteQuantaTask(i, j, inputMatrix, kernel, tempMatrix);
                UpdateProgress(&i, &j, QuantaTask);
                if (PowerLossDetected()) {
                    Checkpoint(i, j, tempMatrix);
                    break;
                }
            } else {
                // Wait for energy to replenish
            }
        }
    }
    
    FuseTasks();
}

void ExecuteQuantaTask(int i, int j, _q31 inputMatrix[][COLS], 
    _q31 kernel[][KERNEL_SIZE], _q31 tempMatrix[][COLS]) {
    for (int ki = 0; ki < KERNEL_SIZE; ki++) {
        for (int kj = 0; kj < KERNEL_SIZE; kj++) {
            msp_conv_iq31(&inputMatrix[i + ki][j + kj], 
                &kernel[ki][kj], &tempMatrix[i][j], COLS, KERNEL_SIZE);
        }
    }
}

void FuseTasks() {
    int remainingEnergy = CheckEnergy(QuantaTask);
    while (remainingEnergy > 0) {
        ExecuteQuantaTask(i, j, inputMatrix, kernel, tempMatrix);
        UpdateProgress(&i, &j, QuantaTask);
        remainingEnergy = CheckEnergy(QuantaTask);
        if (PowerLossDetected()) {
            Checkpoint(i, j, tempMatrix);
            break;
        }
    }
}

int CheckEnergy(int QuantaTask) {
    // Energy checking  - HW interrupt 
    return 1; 
}

int PowerLossDetected() {
    // ower loss detection - HW interrupt logic
    return 0; 
}

void Checkpoint(int i, int j, _q31 tempMatrix[][COLS]) {
    // Disable interrupts to prevent corruption during the write process
    __disable_interrupt();

    // Save the indices i and j to FeRAM
    *((volatile int*)FERAM_ADDR_I) = i;
    *((volatile int*)FERAM_ADDR_J) = j;

    // Save the current state of tempMatrix to FeRAM
    // Assuming tempMatrix is a 2D array of dimensions [ROWS][COLS]
    for (int row = 0; row < ROWS; row++) {
        for (int col = 0; col < COLS; col++) {
            ((volatile _q31*)FERAM_ADDR_TEMPMATRIX)[row * COLS + col] 
                = tempMatrix[row][col];
        }
    }

    // Re-enable interrupts
    __enable_interrupt();
}

void RestoreCheckpoint(int *i, int *j, _q31 tempMatrix[][COLS]) {
    // Disable interrupts
    __disable_interrupt();

    // Restore the indices i and j from FeRAM
    *i = *((volatile int*)FERAM_ADDR_I);
    *j = *((volatile int*)FERAM_ADDR_J);

    // Restore the state of tempMatrix from FeRAM
    for (int row = 0; row < ROWS; row++) {
        for (int col = 0; col < COLS; col++) {
            tempMatrix[row][col] = ((volatile _q31*)
                FERAM_ADDR_TEMPMATRIX)[row * COLS + col];
        }
    }

    // Re-enable interrupts
    __enable_interrupt();
}


void UpdateProgress(int *i, int *j, int QuantaTask) {
    *j += QuantaTask;
    if (*j >= COLS) {
        *j = 0;
        *i += QuantaTask;
    }
}

\end{verbatim}